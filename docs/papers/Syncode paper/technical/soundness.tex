\subsection{Soundness and Completeness}
\label{sec:prop}
This section establishes the soundness and completeness of the \Tool{} algorithm.
Algorithm~\ref{alg:main} presents the LLM generation algorithm with \Tool{}. It takes as inputs an LLM represented by $M$, a tokenizer denoted by $\tokenizer$, an input prompt string $C_0$, the maximum number of generated tokens $n_\textit{max}$, and a base decoding strategy $D$. The algorithm begins by tokenizing the input prompt using the tokenizer. 
It then iteratively generates tokens using the LLM, decodes the current token sequence, and performs parsing to obtain acceptable terminal sequences $\accepts$, and a remainder $\remainder$ (line~\ref{line:acc}). 
A grammar mask is applied to the logit scores based on these values (line~\ref{line:gm}). 
The algorithm subsequently selects the next token using the decoding strategy, and if the end-of-sequence token (EOS) is encountered, the process terminates. 
The final decoded output is obtained, incorporating the generated tokens, and is returned as the result of the MaskedGenerate algorithm.

Given partial output $\partialcode \in \lang_p(G)$, \Tool{} generates a corresponding mask $m$. 
If, for a token $t \in \vocab$, the concatenation $\partialcode.t$ results in a syntactically valid partial output, i.e. $\partialcode.t \in \lang_p(G)$, our soundness theorem ensures that $t$ is indeed a member of the set defined by the generated mask $m$. 
The subsequent theorem formally states this soundness property.

\input{Theorems/theorem1a.tex}
The proof of the theorem is in Appendix~\ref{sec:proofs}.

Next, we give a definition that establishes a partial order on sets of terminal sequences, where given two sets $\accepts_1$ and $\accepts_2$, we say sets $\accepts_1 \greater \accepts_2$ if every sequence in $\accepts_2$ has a prefix in $\accepts_1$.

\begin{definition}[$\greater$]
We define a partial order $\greater$ on set of terminal sequences $\mathcal{P}(\allterminals^*)$ such that $\accepts_1 \greater \accepts_2$ when $\forall \sequence_2 \in \accepts_2 \exists \sequence_1 \in \accepts_1 \exists \sequence_3 \in \allterminals^*  $ s.t. $\sequence_2 = \sequence_1.\sequence_3$
\end{definition}

\input{algorithms/main}
We further state the lemma that shows the relation in the grammar masks generated by two accept sequences satisfying relation $\greater$.

\input{Theorems/lemma4a}
The proof of the lemma is in Appendix~\ref{sec:proofs}.

Theorem~\ref{thm:sound} proves soundness for accept sequences $\accepts_d$ of length $d$, while Lemma~\ref{lemma:porder} extends this proof to any set of accept sequences $\accepts$ where $\accepts \greater \accepts_d$. 
Our implementation, employing sequences of varying lengths, can be proven sound based on this extension.
% Say motivation and pretext for the completeness

The completeness theorem ensures that, under specified conditions, each token $t \in \set(m)$ guarantees $\partialcode.t$ as a syntactically valid partial output.
An implementation of \Tool{} with a short length of accept sequences although sound, may not guarantee completeness.  
To illustrate, let's take the example where $\sequence = \terminal_{f+1}, \terminal_{f+2} \in \accepts$ with simple singleton regular expressions $\regex_{\terminal_{f+1}} =$ \str{(} and $\regex_{\terminal_{f+2}} =$ \str{(}. 
In this case, our algorithm conservatively treats all tokens $t \in \vocab$ as syntactically valid, whenever \str{((} is a prefix of those tokens (e.g., \str{(((}, \str{(()})) even though some tokens may not meet syntactic validity. 
However, by assuming that the accept sequences are long enough, we can establish the completeness of the approach. 
\input{Theorems/theorem2a.tex}

The proof of the theorem is in Appendix~\ref{sec:proofs}. 
While our completeness theorem ensures the \Tool{} consistently extends syntactically correct partial outputs, it does not guarantee termination with a correct and complete output. 
The focus of the theorem is on generating syntactically valid partial outputs, and the theorem does not address whether the process converges to a syntactically correct whole output. 
Termination considerations go beyond the completeness theorem's scope.

